<?php

namespace AppBundle\Repository;
use Doctrine\ORM\EntityManager;

/**
 * MovieRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MovieRepository extends \Doctrine\ORM\EntityRepository
{

    public function getMovies($request){

        $title = $request['title'];
        $releaseDate = $request['releaseDate'];
        $price = $request['price'];

        if (array_key_exists('category', $request))
            $categ = $request['category'];
        else
            $categ = '';
        $actor_search = $request['actor_search'];

        $results = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité. Sinon, il renvoi un tableau de tableau
//                ->select('movie.title', 'movie.alias', 'movie.releaseDate',  'movie.poster', 'category.name cat_name', 'actorAlias.lastname', 'actorAlias.firstname')//on ne regarde jamais la base: on regarde toujours les propriétés de l'entité donc on appelle releaseDate et non pas release_date
                ->join('movie.category', 'category')
                ->leftJoin('movie.actors', 'actorAlias');

        if($title!='')$results = $results->andWhere('movie.title like :title')->setParameter('title', '%'.$title.'%');
        if($price!='')$results = $results->andWhere('movie.price <= :price')->setParameter('price', $price);
        if($categ!='')$results = $results->andWhere('category.id = :categName')->setParameter('categName', $categ);
        if($releaseDate!='')$results = $results->andWhere('YEAR(movie.releaseDate) = :date')->setParameter('date', $releaseDate);
        if($actor_search!='')$results = $results->andWhere('actorAlias.lastname like :actor_search')->setParameter('actor_search', '%'.$actor_search.'%');



//                 ->where('YEAR(movie.releaseDate) > :date')
//                ->andWhere('movie.title = :title')
//                ->andWhere('category.name = :categName')
//                ->andWhere('categoryAlias.name = :actor_search')
//            ->setParameters([
//                'date'=> $releaseDate,
//                'categName'=> $categ,
//                'title'=> $title,
//                'actor_search'=> $actor_search
//            ])

        $results = $results->setFirstResult(0)//a partir de 0
            ->setMaxResults(10)  //jusqu'au 10ieme resultat
            ->orderBy('movie.title', 'ASC')
//            ->orderBy('rand()')

            ->getQuery()
            ->getResult()//getArrayResult

        ;

        //dump($results); exit;

        return $results;

    }

    public function getMoviesByIds($array){



        $results = $this
            ->createQueryBuilder("movie")
            ->andWhere('movie.id IN ('.implode(',', $array).')')
            ->setFirstResult(0)
            ->orderBy('movie.title', 'ASC')
            ->getQuery()
            ->getResult()//getArrayResult

        ;

        return $results;

    }

    public function getMovieByTitle($title){
        $results = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité. Sinon, il renvoi un tableau de tableau
                //->select('movie.title, movie.releaseDate', 'movie.alias', 'movie.poster', 'actors.lastname', 'categoryAlias.name as cat_name')//on ne regarde jamais la base: on regarde toujours les propriétés de l'entité donc on appelle releaseDate et non pas release_date
                ->join('movie.category', 'categoryAlias')
                ->join('movie.actors', 'actors')
                ->where('movie.title like  :title')
            ->setParameters([
                'title'=> '%'.$title.'%'
            ])
            ->setFirstResult(0)//a partir de 0
            ->setMaxResults(10)  //jusqu'au 10ieme resultat
            ->orderBy('movie.title', 'ASC')
//            ->orderBy('rand()')

            ->getQuery()
            ->getResult()//getArrayResult

        ;

        return $results;

    }
public function getMovieByActor($actors){

        $actors = implode(',', $actors);
    //$actors =  implode(',', [51,52,53]);
    //dump($actors); exit;
        $results = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
                ->select('movie.title')
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité. Sinon, il renvoi un tableau de tableau
                //->select('movie.title, movie.releaseDate', 'movie.alias', 'movie.poster', 'actors.lastname', 'categoryAlias.name as cat_name')//on ne regarde jamais la base: on regarde toujours les propriétés de l'entité donc on appelle releaseDate et non pas release_date
                ->join('movie.actors', 'actors')
                ->where('actors.id in ( '. $actors .' )')

            ->setFirstResult(0)//a partir de 0
            ->setMaxResults(10)  //jusqu'au 10ieme resultat
            ->orderBy('movie.title', 'ASC')
//            ->orderBy('rand()')

            ->getQuery()
            ->getResult()//getArrayResult

        ;

        return $results;

    }
public function getYears(){
        $results = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité. Sinon, il renvoi un tableau de tableau
                ->select('DISTINCT movie.releaseDate')//on ne regarde jamais la base: on regarde toujours les propriétés de l'entité donc on appelle releaseDate et non pas release_date
            ->setFirstResult(0)//a partir de 0

            ->orderBy('movie.releaseDate', 'ASC')

            ->getQuery()
            ->getResult()//getArrayResult

        ;

        return $results;

    }

    public function deleteMovieCommande($year, $earlier=null){
        ($earlier ? $sign="<" : $sign=">");
        $results = $this
            ->getEntityManager()
            ->createQuery('
        DELETE FROM
        AppBundle:Movie movie
        WHERE
          movie.releaseDate '.$sign.' :year
          ')
            ->setParameters([
                'year'=>$year
            ])
            ->execute()
            ;

        return $results;
    }

    public function discountMovieCommande($discount){
        $query = "
        UPDATE
        AppBundle:Movie movie
        SET
           movie.price = movie.price - (movie.price * (:rate/100))

        ";
        $results = $this
            ->getEntityManager()
            ->createQuery($query)
            ->setParameters([
                'rate'=>$discount
            ])
            ->execute()
            ;

        return $results;
    }
}
